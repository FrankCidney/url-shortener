package shorten

import (
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"sync"
)

// Generator interface so you can swap generator implementations without touching handlers
type IDGenerator interface {
	Next(url string) (string, error)
}

// ---------------------------------------------------------

// Generator 1: A deterministic base62 generator
// It has zero collisions (each id is generated from an incremented counter value, i.e., each one is generated using a new number)
type Base62Generator struct {
	mu      sync.Mutex
	counter uint64
}

func NewBase62Generator() *Base62Generator {
	return &Base62Generator{}
}

// You need to have a "Next()" function so the Base62Generator implements the IDGenerator interface
func (g *Base62Generator) Next(_ string) (string, error) {
	g.mu.Lock()
	defer g.mu.Unlock()

	g.counter++

	return encodeBase62(g.counter), nil
}

const base62Chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

func encodeBase62(n uint64) string {
	if n == 0 {
		return "0"
	}

	var encoded []byte

	for n > 0 {
		rem := n % 62
		encoded = append(encoded, base62Chars[rem])
		n = n / 62
	}

	// reverse
	for i, j := 0, len(encoded)-1; i < j; i, j = i+1, j-1 {
		encoded[i], encoded[j] = encoded[j], encoded[i]
	}

	return string(encoded)
}

// ------------------------------------------------------------

// Generator 2: URLs generated by hashing them using SHA-256.
// Note that there is a collision risk with this method (i.e., 2 different URLs hashing to the same string (specifically the same truncated string)), because we truncate the URL hash
// thereby reducing the space drastically, making collisions possible if you generate a lot of URLs
type HashGenerator struct {
	length int // how many chars in the short ID
}

func NewHashGenerator(length int) *HashGenerator {
	return &HashGenerator{length: length}
}

func (h *HashGenerator) Next(url string) (string, error) {
	// hash the URL
	hash := sha256.Sum256([]byte(url))

	// encode to base64 (URL-safe) and truncate
	encoded := base64.URLEncoding.EncodeToString(hash[:])

	if len(encoded) < h.length {
		return "", fmt.Errorf("hash too short for requested length")
	}

	return encoded[:h.length], nil
}
